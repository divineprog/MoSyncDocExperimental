<html><head><title>Starting MoSync development for Java and C# developers</title></head><body><h1>MoSync for Java and C# Developers</h1>
<p>Mobile offers developers a new world, with cool devices and nice, easy, small projects compared to that monstrous and boring enterprise code you've been doing in Java or C#, right?&nbsp; Right!&nbsp; However, there are somethings I'm going to tell you to help you move your Java/C# skill to C++ in MoSync.&nbsp; The reality is that both Java and C# are based on syntax from C, so you are going to be able to read C++ source code without anyone having to explain how curly braces work or reminding you to put a semi-colon at the end of the line, which is cool.&nbsp; Java and C# both also have a runtime environment which manages memory and performs garbage collection for you, which C++ doesn't, which isn't cool.&nbsp; Also, it isn't too difficult, and I'm here to guide you through the processes which will save you time and effort, and when you into trouble, the answer will probably already be here.</p>
<p>As you are a Java or C# developer, then you've spent time gathering some fine object-oriented design skills, so we're not going to touch on C code here, this will be about C++ (mostly).</p>
<p>This guide is in three sections, firstly a quick reminder of how C++ works, then a section of how memory management works, and finally unlearning lots of really nice design principles which are perfect for enterprise development, but will cause you grief in mobile.</p>
<p>One final note: this obviously isn't an exhaustive description of how to write in C++.&nbsp; This is what you need to know coming from a Java or C# background to start writing C++, so don't expect this to be the definitive description.&nbsp; This is a quick start guide.</p>
<p>&nbsp;</p>
<h2>How C++ works.</h2>
<p>&nbsp;</p>
<p>
Ok, this isn't really everything you need to know about how C++ works, this is just a reminder about how it can be different.  In C#, if you want to create a new class, you right-click and give the class a name and Visual Studio creates a new templated .cs file for you.  You add in a bit of functionality, and your new class is available within its namespace.  The same is nearly true in C++.  Normally, in C++ you will split your class into two files, a header file and a code file.  The header file will normally have a .h or occasionally a .hpp extension, whilst code files will have .c (for C code) or .cpp (for C++ code). </p>
<p>  
The header file contains the interface definition of your class, although it can contain implementation as well.  In C# when you want to use a specific class you just need to simply include the namespace of the class with a using statement.  In C++, you need to provide a definition of a class before you can use it.  You do this by including the header file of the class in your code using #include "classname.h".  The header is literally included in source code passed to the compiler.  This leads to an issue which you don't get in managed environments.  If you have two classes, Alpha and Beta, you can include them in your new class Gamma like this: </p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>
{syntaxhighlighter brush: cpp;fontsize: 100; first-line: 1; }#include "Alpha.h"
#include "Beta.h"{/syntaxhighlighter}</p>
<p>
However, if Beta.h itself includes Alpha.h, you will get a compilation error when you build Gamma.  This will be because the compiler inserts the code from Alpha.h, then inserts the code from Beta.h, which in turn inserts the code from Alpha.h.  The compiler will complain that methods of Alpha have already been defined.  To prevent this, at the top of your header file, you need to add an include guard.  This is a short compiler directive telling the compiler not to include the header if it has already been included.  In Alpha.h you will write something like this</p>
<p>
{syntaxhighlighter brush: cpp;fontsize: 100; first-line: 1; }#ifndef __ALPHA_H 
#define __ALPHA_H{/syntaxhighlighter}</p>
<p>When you create a new class in MoSync, the template should do this for you.  You can read this as "if there isn't a token called __ALPHA_H then create a token called __ALPHA_H."  At the bottom of the code there will be an #endif to round this off.  You can change the naming convention if you wish, but if you write a header file from scratch, then don't forget the include guard. 
So, in your class you may want to use some classes without specifying their namespace everytime.  This is a very familiar command</p>
<p>&nbsp;</p>
<p>{syntaxhighlighter brush: cpp;fontsize: 100; first-line: 1; }using namespace &lt;namespace&gt;;{/syntaxhighlighter}</p>
<p>Note the semi-colon at the end; this is a C++ command and not a compiler directive. You can create your classes in a namespace in the header file, and again it is familiar</p>
<p>
{syntaxhighlighter brush: cpp;fontsize: 100; first-line: 1; }namespace MyNamespace 
{ 
  ...  
};{/syntaxhighlighter}</p>
<p>Again note the semi-colon at the end.  
Inside any optional namespace declaration, you can create one or more classes (or structs).</p>
<p>&nbsp;</p>
<p>{syntaxhighlighter brush: cpp;fontsize: 100; first-line: 1; }class MyClass 
{ 
  ...  
}; {/syntaxhighlighter}</p>
<p>Once more, take notice of the semi-colon at the end of the class definition.</p>
<p> 
Inside the class, you can create methods.  C++ doesn't support properties in the way you may be used to.  The visibility of methods is also different, as you are able (and encouraged to) define methods in groups by visibility.  A class definition in a header file might typically look like this:</p>
<p>
{syntaxhighlighter brush: cpp;fontsize: 100; first-line: 1; }class Gamma 
{ 
  public: 
    Gamma(); 
    ~Gamma(); 
    
    void incrementCounter(); 
    int getCounter(); 
  protected: 
    int mCounter; 
  private: 
    bool isActive;  
};{/syntaxhighlighter}</p>
<p>
So there are a few things here we can see.  Firstly, there is a class definition as we've seen before.  Inside this are three blocks of member definitions, ordered by visibility.  In the public section, we can see a constructor for Gamma and a destructor (~Gamma()).  The constructor will be called when the class is instantiated and the destructor when it is destroyed.  This maybe obvious, but these are going to become very important in the next two sections of this guide. </p>
<p>
After the destructor, then there are two method declarations, incrementCounter() and getCounter().  We can see that incrementCounter() doesn't return any value and that getCounter() returns an integer.  We've then got two members mCounter and isActive.  You can if you really want define the visibility with each member, but this is unconventional. </p>
<p>
Creating the code to go with the header means creating a .cpp file as well.  To continue this example, we could have Gamma.h and Gamma.cpp to contain the implementation.</p>
<p>
{syntaxhighlighter brush: cpp;fontsize: 100; first-line: 1; }#include "Gamma.h" 
Gamma::Gamma() 
{ 
  mCounter = 0;  
} 
Gamma::~Gamma() 
{ 
} 
void Gamma::incrementCounter() 
{ 
  mCounter++;  
} 
int Gamma::getCounter() 
{ 
  return mCounter;  
}{/syntaxhighlighter}</p>
<p>
Several things to notice here.  Each method needs to start with the class scope Gamma::.  This means that you can implement several classes in the same .cpp, but it isn't normally recommended. Secondly, methods in C++ generally start with a lower-case letter, unlike most Java and C# classes.  Thirdly, C++ doesn't support properties directly in the same way as C#, you need to create a method for get and set.  Finally, as you'd expect, when you create an instance of Gamma, mCounter is set to 0 in the constructor.  There is actually another way to do this, and one which is generally preferred in C++ for two reasons.  The constructor could look like this</p>
<p>&nbsp;</p>
<p>{syntaxhighlighter brush: cpp;fontsize: 100; first-line: 1; }Gamma::Gamma() : mCounter(0) 
{}{/syntaxhighlighter}</p>
<p>mCounter will be initialised with a value of 0.  This can be important in environments where it may be possible to access the class before the constructor has finished executing.    With the initialisation as part of the constructor specification then you are guaranteed availability.  Secondly, if your class defines references (more later), then these cannot be null.  By specifying them in the constructor, then you can assign the reference and avoid this issue.  More on objects, pointers and references soon! </p>
<p>
So, if my class Gamma requires other objects or functions, then the include file can be added in the C++ file, and not in the header.  It is a very good rule to only have the includes you need in the header, and if the class is used entirely internally, then #include it in the cpp file. </p>
<p>
It is possible to have objects as public members in a C++ class, for instance</p>
<p>
{syntaxhighlighter brush: cpp;fontsize: 100; first-line: 1; }class Delta 
{ 
  public: 
    int counter;  
};{/syntaxhighlighter}</p>
<p>This is as bad an idea in C++ as it is in Java and C#.  There is nothing intrinsically wrong with it, but you don't get any opportunity to clean input into mCounter, or to check that its value is only changed when it is safe to do so. </p></body></html>